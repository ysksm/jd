/**
 * Tauri Code Generator
 *
 * Generates Tauri command code from IR schema.
 */

import {
  IRSchema,
  IRModel,
  IRField,
  IRNamespace,
  IROperation,
  TypeRef,
  ScalarKind,
} from "@jira-db/emitter-common";

// ============================================================
// Public API
// ============================================================

/**
 * Generate all Tauri files from IR schema
 */
export function generateTauri(schema: IRSchema): GeneratedFiles {
  const typesContent = generateTypes(schema);
  const commandsContent = generateCommands(schema);
  const modContent = generateMod();

  return {
    "types.rs": typesContent,
    "commands.rs": commandsContent,
    "mod.rs": modContent,
  };
}

export interface GeneratedFiles {
  [filename: string]: string;
}

// ============================================================
// Types Generator
// ============================================================

function generateTypes(schema: IRSchema): string {
  let output = `// Generated by @jira-db/emit-tauri - DO NOT EDIT

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

`;

  for (const model of schema.models) {
    output += generateModel(model);
    output += "\n";
  }

  return output;
}

function generateModel(model: IRModel): string {
  let output = "";

  if (model.doc) {
    output += `/// ${model.doc}\n`;
  }
  output += `#[derive(Debug, Clone, Serialize, Deserialize)]\n`;
  output += `#[serde(rename_all = "camelCase")]\n`;
  output += `pub struct ${model.name} {\n`;

  for (const field of model.fields) {
    output += generateField(field);
  }

  output += `}\n`;
  return output;
}

function generateField(field: IRField): string {
  let output = "";
  const rustType = typeRefToRust(field.type, field.optional);
  const snakeName = toSnakeCase(field.name);

  if (snakeName !== field.name) {
    output += `    #[serde(rename = "${field.name}")]\n`;
  }

  if (field.optional) {
    output += `    #[serde(skip_serializing_if = "Option::is_none")]\n`;
  }

  output += `    pub ${snakeName}: ${rustType},\n`;
  return output;
}

// ============================================================
// Commands Generator
// ============================================================

function generateCommands(schema: IRSchema): string {
  let output = `// Generated by @jira-db/emit-tauri - DO NOT EDIT

use tauri::State;

use super::types::*;
use crate::state::AppState;

`;

  // Generate command functions
  for (const ns of schema.namespaces) {
    output += `// ============================================================\n`;
    output += `// ${ns.name} Commands\n`;
    output += `// ============================================================\n\n`;

    for (const op of ns.operations) {
      output += generateCommand(ns, op);
    }
  }

  // Generate command registration macro
  output += generateRegistrationMacro(schema);

  return output;
}

function generateCommand(ns: IRNamespace, op: IROperation): string {
  const commandName = `${toSnakeCase(ns.name)}_${toSnakeCase(op.name)}`;

  let output = "";
  if (op.doc) {
    output += `/// ${op.doc}\n`;
  }
  output += `#[tauri::command]\n`;
  output += `pub async fn ${commandName}(\n`;
  output += `    state: State<'_, AppState>,\n`;
  output += `    request: ${op.requestType},\n`;
  output += `) -> Result<${op.responseType}, String> {\n`;
  output += `    todo!("Implement ${commandName}")\n`;
  output += `}\n\n`;

  return output;
}

function generateRegistrationMacro(schema: IRSchema): string {
  let output = `// ============================================================
// Command Registration
// ============================================================

/// Register all commands with Tauri
#[macro_export]
macro_rules! register_commands {
    ($builder:expr) => {
        $builder.invoke_handler(tauri::generate_handler![
`;

  for (const ns of schema.namespaces) {
    for (const op of ns.operations) {
      const commandName = `${toSnakeCase(ns.name)}_${toSnakeCase(op.name)}`;
      output += `            ${commandName},\n`;
    }
  }

  output += `        ])
    };
}
`;

  return output;
}

// ============================================================
// Mod Generator
// ============================================================

function generateMod(): string {
  return `// Generated by @jira-db/emit-tauri - DO NOT EDIT

pub mod types;
pub mod commands;

pub use types::*;
pub use commands::*;
`;
}

// ============================================================
// Type Conversion Utilities
// ============================================================

function typeRefToRust(typeRef: TypeRef, optional: boolean): string {
  let rustType: string;

  switch (typeRef.kind) {
    case "scalar":
      rustType = scalarToRust(typeRef.scalar!);
      break;
    case "model":
      rustType = typeRef.modelName!;
      break;
    case "array":
      const elementType = typeRefToRust(typeRef.elementType!, false);
      rustType = `Vec<${elementType}>`;
      break;
    default:
      rustType = "serde_json::Value";
  }

  return optional ? `Option<${rustType}>` : rustType;
}

function scalarToRust(scalar: ScalarKind): string {
  const map: Record<ScalarKind, string> = {
    string: "String",
    boolean: "bool",
    int32: "i32",
    int64: "i64",
    float32: "f32",
    float64: "f64",
    utcDateTime: "DateTime<Utc>",
  };
  return map[scalar] || "String";
}

// ============================================================
// String Utilities
// ============================================================

function toSnakeCase(str: string): string {
  return str.replace(/([A-Z])/g, "_$1").toLowerCase().replace(/^_/, "");
}
