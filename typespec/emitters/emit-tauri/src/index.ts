import {
  EmitContext,
  Model,
  Namespace,
  Program,
  Type,
  getDoc,
  navigateProgram,
} from "@typespec/compiler";

export async function $onEmit(context: EmitContext) {
  const program = context.program;
  const outputDir = context.emitterOutputDir;

  const types = new RustTypeGenerator();
  const commands = new TauriCommandGenerator();

  // Collect all models and operations
  navigateProgram(program, {
    model(model) {
      if (model.namespace?.name !== "TypeSpec") {
        types.addModel(model);
      }
    },
    namespace(namespace) {
      if (isApiNamespace(namespace)) {
        commands.addNamespace(namespace, program);
      }
    },
  });

  // Generate types.rs
  const typesContent = types.generate();
  await context.program.host.writeFile(
    `${outputDir}/types.rs`,
    typesContent
  );

  // Generate commands.rs
  const commandsContent = commands.generate();
  await context.program.host.writeFile(
    `${outputDir}/commands.rs`,
    commandsContent
  );

  // Generate mod.rs
  const modContent = `// Generated by @jira-db/emit-tauri - DO NOT EDIT

pub mod types;
pub mod commands;

pub use types::*;
pub use commands::*;
`;
  await context.program.host.writeFile(`${outputDir}/mod.rs`, modContent);
}

function isApiNamespace(namespace: Namespace): boolean {
  const apiNamespaces = [
    "Config",
    "Projects",
    "Sync",
    "Issues",
    "Metadata",
    "Embeddings",
    "Reports",
  ];
  return apiNamespaces.includes(namespace.name);
}

class RustTypeGenerator {
  private models: Model[] = [];

  addModel(model: Model) {
    this.models.push(model);
  }

  generate(): string {
    let output = `// Generated by @jira-db/emit-tauri - DO NOT EDIT

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

`;

    for (const model of this.models) {
      output += this.generateModel(model);
      output += "\n";
    }

    return output;
  }

  private generateModel(model: Model): string {
    const name = model.name;

    let output = "";
    output += `#[derive(Debug, Clone, Serialize, Deserialize)]\n`;
    output += `#[serde(rename_all = "camelCase")]\n`;
    output += `pub struct ${name} {\n`;

    for (const [fieldName, field] of model.properties) {
      const rustType = this.typeToRust(field.type, field.optional);
      const snakeName = toSnakeCase(fieldName);
      if (snakeName !== fieldName) {
        output += `    #[serde(rename = "${fieldName}")]\n`;
      }
      output += `    pub ${snakeName}: ${rustType},\n`;
    }

    output += `}\n`;
    return output;
  }

  private typeToRust(type: Type, optional: boolean): string {
    let rustType: string;

    switch (type.kind) {
      case "Scalar":
        rustType = this.scalarToRust(type.name);
        break;
      case "Model":
        if (type.name === "Array") {
          const elementType = type.templateMapper?.args?.[0];
          if (elementType && elementType.kind === "Model") {
            rustType = `Vec<${elementType.name}>`;
          } else if (elementType && elementType.kind === "Scalar") {
            rustType = `Vec<${this.scalarToRust((elementType as any).name)}>`;
          } else {
            rustType = "Vec<serde_json::Value>";
          }
        } else {
          rustType = type.name;
        }
        break;
      default:
        rustType = "serde_json::Value";
    }

    return optional ? `Option<${rustType}>` : rustType;
  }

  private scalarToRust(name: string): string {
    switch (name) {
      case "string":
        return "String";
      case "boolean":
        return "bool";
      case "int32":
        return "i32";
      case "int64":
        return "i64";
      case "float32":
        return "f32";
      case "float64":
        return "f64";
      case "utcDateTime":
        return "DateTime<Utc>";
      default:
        return "String";
    }
  }
}

class TauriCommandGenerator {
  private namespaces: Array<{ ns: Namespace; program: Program }> = [];

  addNamespace(namespace: Namespace, program: Program) {
    this.namespaces.push({ ns: namespace, program });
  }

  generate(): string {
    let output = `// Generated by @jira-db/emit-tauri - DO NOT EDIT

use tauri::State;

use super::types::*;
use crate::state::AppState;

`;

    // Generate command functions
    for (const { ns, program } of this.namespaces) {
      output += `// ============================================================\n`;
      output += `// ${ns.name} Commands\n`;
      output += `// ============================================================\n\n`;

      for (const [opName, op] of ns.operations) {
        const commandName = `${toSnakeCase(ns.name)}_${toSnakeCase(opName)}`;
        const requestType = this.getRequestType(ns.name, opName);
        const responseType = this.getResponseType(ns.name, opName);
        const doc = getDoc(program, op) || "";

        if (doc) {
          output += `/// ${doc}\n`;
        }
        output += `#[tauri::command]\n`;
        output += `pub async fn ${commandName}(\n`;
        output += `    state: State<'_, AppState>,\n`;
        output += `    request: ${requestType},\n`;
        output += `) -> Result<${responseType}, String> {\n`;
        output += `    todo!("Implement ${commandName}")\n`;
        output += `}\n\n`;
      }
    }

    // Generate command registration macro
    output += `// ============================================================\n`;
    output += `// Command Registration\n`;
    output += `// ============================================================\n\n`;
    output += `/// Register all commands with Tauri\n`;
    output += `#[macro_export]\n`;
    output += `macro_rules! register_commands {\n`;
    output += `    ($builder:expr) => {\n`;
    output += `        $builder.invoke_handler(tauri::generate_handler![\n`;

    for (const { ns } of this.namespaces) {
      for (const [opName] of ns.operations) {
        const commandName = `${toSnakeCase(ns.name)}_${toSnakeCase(opName)}`;
        output += `            ${commandName},\n`;
      }
    }

    output += `        ])\n`;
    output += `    };\n`;
    output += `}\n`;

    return output;
  }

  private getRequestType(nsName: string, opName: string): string {
    const baseName = capitalize(opName);
    // Handle naming conventions
    if (nsName === "Config") {
      return `Config${baseName}Request`;
    }
    // Remove trailing 's' for singular form (Projects -> Project, Issues -> Issue, etc.)
    const singular = nsName.endsWith("s") ? nsName.slice(0, -1) : nsName;
    return `${singular}${baseName}Request`;
  }

  private getResponseType(nsName: string, opName: string): string {
    const baseName = capitalize(opName);
    if (nsName === "Config") {
      return `Config${baseName}Response`;
    }
    const singular = nsName.endsWith("s") ? nsName.slice(0, -1) : nsName;
    return `${singular}${baseName}Response`;
  }
}

// Utility functions
function toSnakeCase(str: string): string {
  return str.replace(/([A-Z])/g, "_$1").toLowerCase().replace(/^_/, "");
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
