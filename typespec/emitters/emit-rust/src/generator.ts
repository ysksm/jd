/**
 * Rust Code Generator
 *
 * Generates Rust code from IR schema.
 */

import {
  IRSchema,
  IRModel,
  IRField,
  IRNamespace,
  IROperation,
  TypeRef,
  ScalarKind,
} from "@jira-db/emitter-common";

// ============================================================
// Public API
// ============================================================

/**
 * Generate all Rust files from IR schema
 */
export function generateRust(schema: IRSchema): GeneratedFiles {
  const typesContent = generateTypes(schema);
  const handlersContent = generateHandlers(schema);
  const modContent = generateMod();

  return {
    "types.rs": typesContent,
    "handlers.rs": handlersContent,
    "mod.rs": modContent,
  };
}

export interface GeneratedFiles {
  [filename: string]: string;
}

// ============================================================
// Types Generator
// ============================================================

function generateTypes(schema: IRSchema): string {
  let output = `// Generated by @jira-db/emit-rust - DO NOT EDIT

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

`;

  for (const model of schema.models) {
    output += generateModel(model);
    output += "\n";
  }

  return output;
}

function generateModel(model: IRModel): string {
  let output = "";

  if (model.doc) {
    output += `/// ${model.doc}\n`;
  }
  output += `#[derive(Debug, Clone, Serialize, Deserialize)]\n`;
  output += `#[serde(rename_all = "camelCase")]\n`;
  output += `pub struct ${model.name} {\n`;

  for (const field of model.fields) {
    output += generateField(field);
  }

  output += `}\n`;
  return output;
}

function generateField(field: IRField): string {
  let output = "";
  const rustType = typeRefToRust(field.type, field.optional);
  const snakeName = toSnakeCase(field.name);

  // Add serde rename if needed
  if (snakeName !== field.name) {
    output += `    #[serde(rename = "${field.name}")]\n`;
  }

  // Add skip_serializing_if for optional fields
  if (field.optional) {
    output += `    #[serde(skip_serializing_if = "Option::is_none")]\n`;
  }

  output += `    pub ${snakeName}: ${rustType},\n`;
  return output;
}

// ============================================================
// Handlers Generator
// ============================================================

function generateHandlers(schema: IRSchema): string {
  let output = `// Generated by @jira-db/emit-rust - DO NOT EDIT

use std::sync::Arc;

use axum::{
    extract::State,
    routing::post,
    Json, Router,
};

use super::types::*;
use crate::error::ApiError;
use crate::handlers;
use crate::state::AppState;

/// Create router with all API endpoints
pub fn create_router() -> Router<Arc<AppState>> {
    Router::new()
`;

  // Generate routes
  for (const ns of schema.namespaces) {
    for (const op of ns.operations) {
      const route = `/${toKebabCase(ns.name)}.${toKebabCase(op.name)}`;
      const handlerName = `${toSnakeCase(ns.name)}_${toSnakeCase(op.name)}`;
      output += `        .route("${route}", post(${handlerName}))\n`;
    }
  }

  output += `}

// ============================================================
// Handler Functions
// ============================================================

`;

  // Generate handler functions
  for (const ns of schema.namespaces) {
    output += `// -- ${ns.name} --\n\n`;

    for (const op of ns.operations) {
      output += generateHandler(ns, op);
    }
  }

  return output;
}

function generateHandler(ns: IRNamespace, op: IROperation): string {
  const handlerName = `${toSnakeCase(ns.name)}_${toSnakeCase(op.name)}`;
  const handlerModule = toSnakeCase(ns.name);

  let output = "";
  if (op.doc) {
    output += `/// ${op.doc}\n`;
  }
  output += `async fn ${handlerName}(\n`;
  output += `    State(state): State<Arc<AppState>>,\n`;
  output += `    Json(request): Json<${op.requestType}>,\n`;
  output += `) -> Result<Json<${op.responseType}>, ApiError> {\n`;
  output += `    handlers::${handlerModule}::${toSnakeCase(op.name)}(state, request).await\n`;
  output += `}\n\n`;

  return output;
}

// ============================================================
// Mod Generator
// ============================================================

function generateMod(): string {
  return `// Generated by @jira-db/emit-rust - DO NOT EDIT

pub mod types;
pub mod handlers;

pub use types::*;
pub use handlers::*;
`;
}

// ============================================================
// Type Conversion Utilities
// ============================================================

function typeRefToRust(typeRef: TypeRef, optional: boolean): string {
  let rustType: string;

  switch (typeRef.kind) {
    case "scalar":
      rustType = scalarToRust(typeRef.scalar!);
      break;
    case "model":
      rustType = typeRef.modelName!;
      break;
    case "array":
      const elementType = typeRefToRust(typeRef.elementType!, false);
      rustType = `Vec<${elementType}>`;
      break;
    default:
      rustType = "serde_json::Value";
  }

  return optional ? `Option<${rustType}>` : rustType;
}

function scalarToRust(scalar: ScalarKind): string {
  const map: Record<ScalarKind, string> = {
    string: "String",
    boolean: "bool",
    int32: "i32",
    int64: "i64",
    float32: "f32",
    float64: "f64",
    utcDateTime: "DateTime<Utc>",
  };
  return map[scalar] || "String";
}

// ============================================================
// String Utilities
// ============================================================

function toSnakeCase(str: string): string {
  return str.replace(/([A-Z])/g, "_$1").toLowerCase().replace(/^_/, "");
}

function toKebabCase(str: string): string {
  return str.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
}
