import {
  EmitContext,
  Model,
  Namespace,
  Operation,
  Program,
  Type,
  getDoc,
  navigateProgram,
} from "@typespec/compiler";

export async function $onEmit(context: EmitContext) {
  const program = context.program;
  const outputDir = context.emitterOutputDir;

  const types = new RustTypeGenerator();
  const handlers = new RustHandlerGenerator();

  // Collect all models and operations
  navigateProgram(program, {
    model(model) {
      if (model.namespace?.name !== "TypeSpec") {
        types.addModel(model);
      }
    },
    namespace(namespace) {
      if (isApiNamespace(namespace)) {
        handlers.addNamespace(namespace, program);
      }
    },
  });

  // Generate types.rs
  const typesContent = types.generate();
  await context.program.host.writeFile(
    `${outputDir}/types.rs`,
    typesContent
  );

  // Generate handlers.rs
  const handlersContent = handlers.generate();
  await context.program.host.writeFile(
    `${outputDir}/handlers.rs`,
    handlersContent
  );

  // Generate mod.rs
  const modContent = `// Generated by @jira-db/emit-rust - DO NOT EDIT

pub mod types;
pub mod handlers;

pub use types::*;
pub use handlers::*;
`;
  await context.program.host.writeFile(`${outputDir}/mod.rs`, modContent);
}

function isApiNamespace(namespace: Namespace): boolean {
  const apiNamespaces = [
    "Config",
    "Projects",
    "Sync",
    "Issues",
    "Metadata",
    "Embeddings",
    "Reports",
  ];
  return apiNamespaces.includes(namespace.name);
}

class RustTypeGenerator {
  private models: Model[] = [];

  addModel(model: Model) {
    this.models.push(model);
  }

  generate(): string {
    let output = `// Generated by @jira-db/emit-rust - DO NOT EDIT

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

`;

    for (const model of this.models) {
      output += this.generateModel(model);
      output += "\n";
    }

    return output;
  }

  private generateModel(model: Model): string {
    const name = model.name;
    const doc = getDoc(model.node?.symbol?.declarations?.[0]?.parent?.parent as any) || "";

    let output = "";
    if (doc) {
      output += `/// ${doc}\n`;
    }
    output += `#[derive(Debug, Clone, Serialize, Deserialize)]\n`;
    output += `#[serde(rename_all = "camelCase")]\n`;
    output += `pub struct ${name} {\n`;

    for (const [fieldName, field] of model.properties) {
      const rustType = this.typeToRust(field.type, field.optional);
      const snakeName = toSnakeCase(fieldName);
      if (snakeName !== fieldName) {
        output += `    #[serde(rename = "${fieldName}")]\n`;
      }
      output += `    pub ${snakeName}: ${rustType},\n`;
    }

    output += `}\n`;
    return output;
  }

  private typeToRust(type: Type, optional: boolean): string {
    let rustType: string;

    switch (type.kind) {
      case "Scalar":
        rustType = this.scalarToRust(type.name);
        break;
      case "Model":
        if (type.name === "Array") {
          const elementType = type.templateMapper?.args?.[0];
          if (elementType && elementType.kind === "Model") {
            rustType = `Vec<${elementType.name}>`;
          } else if (elementType && elementType.kind === "Scalar") {
            rustType = `Vec<${this.scalarToRust((elementType as any).name)}>`;
          } else {
            rustType = "Vec<serde_json::Value>";
          }
        } else {
          rustType = type.name;
        }
        break;
      case "Union":
        rustType = "serde_json::Value";
        break;
      default:
        rustType = "serde_json::Value";
    }

    return optional ? `Option<${rustType}>` : rustType;
  }

  private scalarToRust(name: string): string {
    switch (name) {
      case "string":
        return "String";
      case "boolean":
        return "bool";
      case "int32":
        return "i32";
      case "int64":
        return "i64";
      case "float32":
        return "f32";
      case "float64":
        return "f64";
      case "utcDateTime":
        return "DateTime<Utc>";
      default:
        return "String";
    }
  }
}

class RustHandlerGenerator {
  private namespaces: Array<{ ns: Namespace; program: Program }> = [];

  addNamespace(namespace: Namespace, program: Program) {
    this.namespaces.push({ ns: namespace, program });
  }

  generate(): string {
    let output = `// Generated by @jira-db/emit-rust - DO NOT EDIT

use axum::{
    extract::State,
    routing::post,
    Json, Router,
};
use std::sync::Arc;

use super::types::*;
use crate::state::AppState;
use crate::error::ApiError;

/// Create router with all API endpoints
pub fn create_router() -> Router<Arc<AppState>> {
    Router::new()
`;

    for (const { ns } of this.namespaces) {
      for (const [opName, op] of ns.operations) {
        const route = `/${toKebabCase(ns.name)}.${toKebabCase(opName)}`;
        const handlerName = `${toSnakeCase(ns.name)}_${toSnakeCase(opName)}`;
        output += `        .route("${route}", post(${handlerName}))\n`;
      }
    }

    output += `}

// ============================================================
// Handler Stubs - Implement these in separate files
// ============================================================

`;

    for (const { ns, program } of this.namespaces) {
      output += `// -- ${ns.name} --\n\n`;

      for (const [opName, op] of ns.operations) {
        const handlerName = `${toSnakeCase(ns.name)}_${toSnakeCase(opName)}`;
        const requestType = this.getRequestType(ns.name, opName);
        const responseType = this.getResponseType(ns.name, opName);
        const doc = getDoc(program, op) || "";

        if (doc) {
          output += `/// ${doc}\n`;
        }
        output += `pub async fn ${handlerName}(\n`;
        output += `    State(state): State<Arc<AppState>>,\n`;
        output += `    Json(request): Json<${requestType}>,\n`;
        output += `) -> Result<Json<${responseType}>, ApiError> {\n`;
        output += `    todo!("Implement ${handlerName}")\n`;
        output += `}\n\n`;
      }
    }

    return output;
  }

  private getRequestType(nsName: string, opName: string): string {
    const baseName = capitalize(opName);
    return `${nsName === "Config" ? "Config" : nsName.slice(0, -1)}${baseName}Request`;
  }

  private getResponseType(nsName: string, opName: string): string {
    const baseName = capitalize(opName);
    return `${nsName === "Config" ? "Config" : nsName.slice(0, -1)}${baseName}Response`;
  }
}

// Utility functions
function toSnakeCase(str: string): string {
  return str.replace(/([A-Z])/g, "_$1").toLowerCase().replace(/^_/, "");
}

function toKebabCase(str: string): string {
  return str.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
