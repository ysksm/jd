import {
  EmitContext,
  Model,
  Namespace,
  Program,
  Type,
  getDoc,
  navigateProgram,
} from "@typespec/compiler";

export async function $onEmit(context: EmitContext) {
  const program = context.program;
  const outputDir = context.emitterOutputDir;

  const types = new TypeScriptModelGenerator();
  const services = new AngularServiceGenerator();

  // Collect all models and operations
  navigateProgram(program, {
    model(model) {
      if (model.namespace?.name !== "TypeSpec") {
        types.addModel(model);
      }
    },
    namespace(namespace) {
      if (isApiNamespace(namespace)) {
        services.addNamespace(namespace, program);
      }
    },
  });

  // Generate models.ts
  const modelsContent = types.generate();
  await context.program.host.writeFile(
    `${outputDir}/models.ts`,
    modelsContent
  );

  // Generate api.service.ts
  const serviceContent = services.generate();
  await context.program.host.writeFile(
    `${outputDir}/api.service.ts`,
    serviceContent
  );

  // Generate tauri-api.service.ts (for Tauri invoke)
  const tauriServiceContent = services.generateTauriService();
  await context.program.host.writeFile(
    `${outputDir}/tauri-api.service.ts`,
    tauriServiceContent
  );

  // Generate index.ts
  const indexContent = `// Generated by @jira-db/emit-angular - DO NOT EDIT

export * from './models';
export * from './api.service';
export * from './tauri-api.service';
`;
  await context.program.host.writeFile(`${outputDir}/index.ts`, indexContent);
}

function isApiNamespace(namespace: Namespace): boolean {
  const apiNamespaces = [
    "Config",
    "Projects",
    "Sync",
    "Issues",
    "Metadata",
    "Embeddings",
    "Reports",
  ];
  return apiNamespaces.includes(namespace.name);
}

class TypeScriptModelGenerator {
  private models: Model[] = [];

  addModel(model: Model) {
    this.models.push(model);
  }

  generate(): string {
    let output = `// Generated by @jira-db/emit-angular - DO NOT EDIT

`;

    for (const model of this.models) {
      output += this.generateInterface(model);
      output += "\n";
    }

    return output;
  }

  private generateInterface(model: Model): string {
    const name = model.name;

    let output = `export interface ${name} {\n`;

    for (const [fieldName, field] of model.properties) {
      const tsType = this.typeToTypeScript(field.type);
      const optional = field.optional ? "?" : "";
      output += `  ${fieldName}${optional}: ${tsType};\n`;
    }

    output += `}\n`;
    return output;
  }

  private typeToTypeScript(type: Type): string {
    switch (type.kind) {
      case "Scalar":
        return this.scalarToTypeScript(type.name);
      case "Model":
        if (type.name === "Array") {
          const elementType = type.templateMapper?.args?.[0];
          if (elementType && elementType.kind === "Model") {
            return `${elementType.name}[]`;
          } else if (elementType && elementType.kind === "Scalar") {
            return `${this.scalarToTypeScript((elementType as any).name)}[]`;
          }
          return "unknown[]";
        }
        return type.name;
      case "Union":
        return "unknown";
      default:
        return "unknown";
    }
  }

  private scalarToTypeScript(name: string): string {
    switch (name) {
      case "string":
        return "string";
      case "boolean":
        return "boolean";
      case "int32":
      case "int64":
      case "float32":
      case "float64":
        return "number";
      case "utcDateTime":
        return "string"; // ISO 8601 string
      default:
        return "string";
    }
  }
}

class AngularServiceGenerator {
  private namespaces: Array<{ ns: Namespace; program: Program }> = [];

  addNamespace(namespace: Namespace, program: Program) {
    this.namespaces.push({ ns: namespace, program });
  }

  generate(): string {
    let output = `// Generated by @jira-db/emit-angular - DO NOT EDIT

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

import {
`;

    // Import all request/response types
    const importTypes = new Set<string>();
    for (const { ns } of this.namespaces) {
      for (const [opName] of ns.operations) {
        importTypes.add(this.getRequestType(ns.name, opName));
        importTypes.add(this.getResponseType(ns.name, opName));
      }
    }
    output += Array.from(importTypes).map(t => `  ${t},`).join("\n");
    output += `
} from './models';

@Injectable({ providedIn: 'root' })
export class ApiService {
  private baseUrl = '/api';

  constructor(private http: HttpClient) {}

`;

    for (const { ns, program } of this.namespaces) {
      output += `  // ----------------------------------------\n`;
      output += `  // ${ns.name}\n`;
      output += `  // ----------------------------------------\n\n`;

      for (const [opName, op] of ns.operations) {
        const methodName = `${toCamelCase(ns.name)}${capitalize(opName)}`;
        const requestType = this.getRequestType(ns.name, opName);
        const responseType = this.getResponseType(ns.name, opName);
        const endpoint = `/${toKebabCase(ns.name)}.${toKebabCase(opName)}`;
        const doc = getDoc(program, op) || "";

        if (doc) {
          output += `  /** ${doc} */\n`;
        }
        output += `  ${methodName}(request: ${requestType}): Observable<${responseType}> {\n`;
        output += `    return this.http.post<${responseType}>(\`\${this.baseUrl}${endpoint}\`, request);\n`;
        output += `  }\n\n`;
      }
    }

    output += `}\n`;
    return output;
  }

  generateTauriService(): string {
    let output = `// Generated by @jira-db/emit-angular - DO NOT EDIT

import { Injectable } from '@angular/core';
import { invoke } from '@tauri-apps/api/core';
import { from, Observable } from 'rxjs';

import {
`;

    // Import all request/response types
    const importTypes = new Set<string>();
    for (const { ns } of this.namespaces) {
      for (const [opName] of ns.operations) {
        importTypes.add(this.getRequestType(ns.name, opName));
        importTypes.add(this.getResponseType(ns.name, opName));
      }
    }
    output += Array.from(importTypes).map(t => `  ${t},`).join("\n");
    output += `
} from './models';

@Injectable({ providedIn: 'root' })
export class TauriApiService {
`;

    for (const { ns, program } of this.namespaces) {
      output += `  // ----------------------------------------\n`;
      output += `  // ${ns.name}\n`;
      output += `  // ----------------------------------------\n\n`;

      for (const [opName, op] of ns.operations) {
        const methodName = `${toCamelCase(ns.name)}${capitalize(opName)}`;
        const commandName = `${toSnakeCase(ns.name)}_${toSnakeCase(opName)}`;
        const requestType = this.getRequestType(ns.name, opName);
        const responseType = this.getResponseType(ns.name, opName);
        const doc = getDoc(program, op) || "";

        if (doc) {
          output += `  /** ${doc} */\n`;
        }
        output += `  ${methodName}(request: ${requestType}): Observable<${responseType}> {\n`;
        output += `    return from(invoke<${responseType}>('${commandName}', { request }));\n`;
        output += `  }\n\n`;
      }
    }

    output += `}\n`;
    return output;
  }

  private getRequestType(nsName: string, opName: string): string {
    const baseName = capitalize(opName);
    if (nsName === "Config") {
      return `Config${baseName}Request`;
    }
    const singular = nsName.endsWith("s") ? nsName.slice(0, -1) : nsName;
    return `${singular}${baseName}Request`;
  }

  private getResponseType(nsName: string, opName: string): string {
    const baseName = capitalize(opName);
    if (nsName === "Config") {
      return `Config${baseName}Response`;
    }
    const singular = nsName.endsWith("s") ? nsName.slice(0, -1) : nsName;
    return `${singular}${baseName}Response`;
  }
}

// Utility functions
function toSnakeCase(str: string): string {
  return str.replace(/([A-Z])/g, "_$1").toLowerCase().replace(/^_/, "");
}

function toKebabCase(str: string): string {
  return str.replace(/([A-Z])/g, "-$1").toLowerCase().replace(/^-/, "");
}

function toCamelCase(str: string): string {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
