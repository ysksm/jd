//! AI-powered test data generation use case
//!
//! Uses Claude API to generate realistic JIRA issues including:
//! - Epics with related stories and tasks
//! - Bugs with realistic lifecycle
//! - Time-series data suitable for burndown charts

use std::collections::HashMap;
use std::sync::Arc;

use chrono::{Duration, Utc};

use crate::application::dto::CreatedIssueDto;
use crate::application::services::JiraService;
use crate::domain::entities::IssueType;
use crate::domain::error::{DomainError, DomainResult};
use crate::infrastructure::external::claude::{
    AiTestDataGenerator, ClaudeCliClient, ClaudeClient, ClaudeConfig, GeneratedIssue,
    SprintScenario,
};

/// Issue type mapper for mapping AI-generated types to actual project types
struct IssueTypeMapper {
    /// Map from canonical type (Epic, Story, Task, Bug) to actual project issue type name
    type_map: HashMap<String, String>,
}

impl IssueTypeMapper {
    /// Create a new mapper from project issue types
    fn new(issue_types: &[IssueType]) -> Self {
        let mut type_map = HashMap::new();

        // Canonical types we look for (case-insensitive matching)
        let canonical_types = ["Epic", "Story", "Task", "Bug"];

        for canonical in &canonical_types {
            let canonical_lower = canonical.to_lowercase();

            // Try exact match first
            if let Some(it) = issue_types
                .iter()
                .find(|it| it.name.to_lowercase() == canonical_lower)
            {
                type_map.insert(canonical.to_string(), it.name.clone());
                continue;
            }

            // Try partial match (e.g., "User Story" matches "Story")
            if let Some(it) = issue_types
                .iter()
                .find(|it| it.name.to_lowercase().contains(&canonical_lower))
            {
                type_map.insert(canonical.to_string(), it.name.clone());
                continue;
            }

            // Special cases for common Japanese JIRA setups
            let alternatives: &[&str] = match *canonical {
                "Epic" => &["エピック"],
                "Story" => &["ストーリー", "User Story", "ユーザーストーリー"],
                "Task" => &["タスク", "Sub-task", "サブタスク"],
                "Bug" => &["バグ", "不具合", "Defect"],
                _ => &[],
            };

            for alt in alternatives {
                let alt_lower = alt.to_lowercase();
                if let Some(it) = issue_types
                    .iter()
                    .find(|it| it.name.to_lowercase() == alt_lower)
                {
                    type_map.insert(canonical.to_string(), it.name.clone());
                    break;
                }
            }
        }

        Self { type_map }
    }

    /// Map a canonical issue type to the actual project issue type
    fn map_type(&self, canonical_type: &str) -> Option<&str> {
        self.type_map.get(canonical_type).map(|s| s.as_str())
    }

    /// Get all available mapped types for logging
    fn available_types(&self) -> Vec<(&str, &str)> {
        self.type_map
            .iter()
            .map(|(k, v)| (k.as_str(), v.as_str()))
            .collect()
    }
}

/// Result of AI test data generation
#[derive(Debug, Clone)]
pub struct AiTestDataResult {
    /// Generated sprint scenario
    pub scenario: SprintScenario,
    /// Created issues in JIRA
    pub created_issues: Vec<CreatedIssueInfo>,
    /// Issues that failed to create
    pub failed_issues: Vec<FailedIssueInfo>,
    /// Summary statistics
    pub stats: GenerationStats,
}

/// Information about a created issue
#[derive(Debug, Clone)]
pub struct CreatedIssueInfo {
    /// JIRA issue key
    pub key: String,
    /// JIRA issue ID
    pub id: String,
    /// Issue type
    pub issue_type: String,
    /// Issue summary
    pub summary: String,
    /// Current status
    pub status: String,
    /// Self URL
    pub self_url: Option<String>,
}

/// Information about a failed issue creation
#[derive(Debug, Clone)]
pub struct FailedIssueInfo {
    /// Issue type that was attempted
    pub issue_type: String,
    /// Summary that was attempted
    pub summary: String,
    /// Error message
    pub error: String,
}

/// Statistics about the generation
#[derive(Debug, Clone, Default)]
pub struct GenerationStats {
    /// Total issues generated by AI
    pub total_generated: usize,
    /// Issues successfully created in JIRA
    pub successfully_created: usize,
    /// Issues that failed to create
    pub failed_to_create: usize,
    /// Epics created
    pub epics_created: usize,
    /// Stories created
    pub stories_created: usize,
    /// Tasks created
    pub tasks_created: usize,
    /// Bugs created
    pub bugs_created: usize,
    /// Transitions applied
    pub transitions_applied: usize,
    /// Links created between issues
    pub links_created: usize,
    /// Due dates set
    pub due_dates_set: usize,
}

/// Configuration for AI test data generation
#[derive(Debug, Clone)]
pub struct AiTestDataConfig {
    /// Project context/description for AI
    pub project_context: String,
    /// Team size (number of developers)
    pub team_size: usize,
    /// Sprint duration in days
    pub sprint_duration_days: i32,
    /// Whether to apply status transitions based on timeline
    pub apply_transitions: bool,
    /// Anthropic API key
    pub anthropic_api_key: String,
    /// Use faster/cheaper model (Haiku)
    pub use_fast_model: bool,
    /// Use Claude CLI (claude -p) instead of API
    pub use_claude_cli: bool,
}

impl Default for AiTestDataConfig {
    fn default() -> Self {
        Self {
            project_context: "A web application project with frontend and backend components"
                .to_string(),
            team_size: 4,
            sprint_duration_days: 14,
            apply_transitions: true,
            anthropic_api_key: String::new(),
            use_fast_model: false,
            use_claude_cli: false,
        }
    }
}

/// Use case for generating AI-powered test data
pub struct GenerateAiTestDataUseCase<J: JiraService> {
    jira_service: Arc<J>,
}

impl<J: JiraService> GenerateAiTestDataUseCase<J> {
    /// Create a new use case instance
    pub fn new(jira_service: Arc<J>) -> Self {
        Self { jira_service }
    }

    /// Execute the use case to generate test data for a project
    pub async fn execute(
        &self,
        project_key: &str,
        config: &AiTestDataConfig,
    ) -> DomainResult<AiTestDataResult> {
        // Fetch available issue types for the project
        log::info!("Fetching issue types for project {}...", project_key);
        let issue_types = self
            .jira_service
            .fetch_issue_types_by_project_key(project_key)
            .await?;

        let type_mapper = IssueTypeMapper::new(&issue_types);
        log::info!(
            "Available issue type mappings: {:?}",
            type_mapper.available_types()
        );

        // Generate sprint scenario using AI
        log::info!(
            "Generating sprint scenario with AI for project {}...",
            project_key
        );

        let scenario = if config.use_claude_cli {
            // Use Claude CLI
            log::info!("Using Claude CLI for generation");
            let client = ClaudeCliClient::new();
            client
                .generate_sprint_scenario(
                    &config.project_context,
                    config.team_size,
                    config.sprint_duration_days,
                )
                .await?
        } else {
            // Use Claude API
            let claude_config = if config.use_fast_model {
                ClaudeConfig::new(&config.anthropic_api_key).with_haiku()
            } else {
                ClaudeConfig::new(&config.anthropic_api_key)
            };
            let claude_client = ClaudeClient::new(claude_config)?;
            claude_client
                .generate_sprint_scenario(
                    &config.project_context,
                    config.team_size,
                    config.sprint_duration_days,
                )
                .await?
        };

        log::info!(
            "AI generated {} issues for sprint '{}'",
            scenario.issues.len(),
            scenario.sprint_name
        );

        // Create issues in JIRA
        let mut created_issues = Vec::new();
        let mut failed_issues = Vec::new();
        let mut stats = GenerationStats::default();
        stats.total_generated = scenario.issues.len();

        // Map from original index to created issue key
        let mut index_to_key: HashMap<usize, String> = HashMap::new();

        // First pass: Create epics and get their keys
        let mut epic_key_map: HashMap<usize, String> = HashMap::new();

        for (idx, issue) in scenario.issues.iter().enumerate() {
            if issue.issue_type == "Epic" {
                match self
                    .create_issue_with_mapper(project_key, issue, None, &type_mapper)
                    .await
                {
                    Ok(created) => {
                        epic_key_map.insert(idx, created.key.clone());
                        index_to_key.insert(idx, created.key.clone());
                        stats.epics_created += 1;
                        stats.successfully_created += 1;
                        created_issues.push(CreatedIssueInfo {
                            key: created.key,
                            id: created.id,
                            issue_type: issue.issue_type.clone(),
                            summary: issue.summary.clone(),
                            status: "To Do".to_string(),
                            self_url: created.self_url,
                        });
                    }
                    Err(e) => {
                        stats.failed_to_create += 1;
                        failed_issues.push(FailedIssueInfo {
                            issue_type: issue.issue_type.clone(),
                            summary: issue.summary.clone(),
                            error: e.to_string(),
                        });
                    }
                }
            }
        }

        // Get the first epic key for stories that reference "EPIC"
        let first_epic_key = epic_key_map.values().next().cloned();

        // Second pass: Create stories, tasks, and bugs
        for (idx, issue) in scenario.issues.iter().enumerate() {
            if issue.issue_type == "Epic" {
                continue; // Already created
            }

            // Determine parent key for stories
            let parent_key = if issue.issue_type == "Story" && issue.parent_key.is_some() {
                first_epic_key.as_deref()
            } else {
                None
            };

            match self
                .create_issue_with_mapper(project_key, issue, parent_key, &type_mapper)
                .await
            {
                Ok(created) => {
                    index_to_key.insert(idx, created.key.clone());
                    stats.successfully_created += 1;
                    match issue.issue_type.as_str() {
                        "Story" => stats.stories_created += 1,
                        "Task" => stats.tasks_created += 1,
                        "Bug" => stats.bugs_created += 1,
                        _ => {}
                    }

                    let mut info = CreatedIssueInfo {
                        key: created.key.clone(),
                        id: created.id,
                        issue_type: issue.issue_type.clone(),
                        summary: issue.summary.clone(),
                        status: "To Do".to_string(),
                        self_url: created.self_url,
                    };

                    // Apply transitions if configured
                    if config.apply_transitions {
                        if let Some(new_status) =
                            self.apply_timeline_transitions(&created.key, issue).await
                        {
                            info.status = new_status;
                            stats.transitions_applied += 1;
                        }
                    }

                    created_issues.push(info);
                }
                Err(e) => {
                    stats.failed_to_create += 1;
                    failed_issues.push(FailedIssueInfo {
                        issue_type: issue.issue_type.clone(),
                        summary: issue.summary.clone(),
                        error: e.to_string(),
                    });
                }
            }
        }

        // Third pass: Set due dates and create issue links
        let sprint_start = Utc::now();

        for (idx, issue) in scenario.issues.iter().enumerate() {
            let Some(issue_key) = index_to_key.get(&idx) else {
                continue; // Issue wasn't created
            };

            // Set due date if specified
            if let Some(due_offset) = issue.due_day_offset {
                let due_date = sprint_start + Duration::days(due_offset as i64);
                let due_date_str = due_date.format("%Y-%m-%d").to_string();

                if self
                    .jira_service
                    .update_issue_due_date(issue_key, &due_date_str)
                    .await
                    .is_ok()
                {
                    stats.due_dates_set += 1;
                }
            }

            // Create "Blocks" links
            for &blocked_idx in &issue.blocks {
                if let Some(blocked_key) = index_to_key.get(&blocked_idx) {
                    if self
                        .jira_service
                        .create_issue_link("Blocks", blocked_key, issue_key)
                        .await
                        .is_ok()
                    {
                        stats.links_created += 1;
                    }
                }
            }

            // Create "Relates" links
            for &related_idx in &issue.relates_to {
                if let Some(related_key) = index_to_key.get(&related_idx) {
                    // Only create link once (avoid duplicate if both sides reference each other)
                    if idx < related_idx {
                        if self
                            .jira_service
                            .create_issue_link("Relates", related_key, issue_key)
                            .await
                            .is_ok()
                        {
                            stats.links_created += 1;
                        }
                    }
                }
            }
        }

        Ok(AiTestDataResult {
            scenario,
            created_issues,
            failed_issues,
            stats,
        })
    }

    /// Generate only a single epic with its stories
    pub async fn generate_epic(
        &self,
        project_key: &str,
        config: &AiTestDataConfig,
        epic_theme: &str,
    ) -> DomainResult<AiTestDataResult> {
        // Fetch available issue types for the project
        log::info!("Fetching issue types for project {}...", project_key);
        let issue_types = self
            .jira_service
            .fetch_issue_types_by_project_key(project_key)
            .await?;

        let type_mapper = IssueTypeMapper::new(&issue_types);
        log::info!(
            "Available issue type mappings: {:?}",
            type_mapper.available_types()
        );

        // Generate epic
        log::info!("Generating epic '{}' with AI...", epic_theme);

        let issues = if config.use_claude_cli {
            // Use Claude CLI
            log::info!("Using Claude CLI for generation");
            let client = ClaudeCliClient::new();
            client
                .generate_epic(&config.project_context, epic_theme)
                .await?
        } else {
            // Use Claude API
            let claude_config = if config.use_fast_model {
                ClaudeConfig::new(&config.anthropic_api_key).with_haiku()
            } else {
                ClaudeConfig::new(&config.anthropic_api_key)
            };
            let claude_client = ClaudeClient::new(claude_config)?;
            claude_client
                .generate_epic(&config.project_context, epic_theme)
                .await?
        };

        let scenario = SprintScenario {
            sprint_name: format!("Epic: {}", epic_theme),
            duration_days: config.sprint_duration_days,
            team_members: vec![],
            issues,
        };

        // Create in JIRA (similar to execute)
        let mut created_issues = Vec::new();
        let mut failed_issues = Vec::new();
        let mut stats = GenerationStats::default();
        stats.total_generated = scenario.issues.len();

        // Create epic first
        let mut epic_key: Option<String> = None;
        for issue in &scenario.issues {
            if issue.issue_type == "Epic" {
                match self
                    .create_issue_with_mapper(project_key, issue, None, &type_mapper)
                    .await
                {
                    Ok(created) => {
                        epic_key = Some(created.key.clone());
                        stats.epics_created += 1;
                        stats.successfully_created += 1;
                        created_issues.push(CreatedIssueInfo {
                            key: created.key,
                            id: created.id,
                            issue_type: issue.issue_type.clone(),
                            summary: issue.summary.clone(),
                            status: "To Do".to_string(),
                            self_url: created.self_url,
                        });
                    }
                    Err(e) => {
                        stats.failed_to_create += 1;
                        failed_issues.push(FailedIssueInfo {
                            issue_type: issue.issue_type.clone(),
                            summary: issue.summary.clone(),
                            error: e.to_string(),
                        });
                    }
                }
                break;
            }
        }

        // Create stories and tasks
        for issue in &scenario.issues {
            if issue.issue_type == "Epic" {
                continue;
            }

            let parent = if issue.issue_type == "Story" {
                epic_key.as_deref()
            } else {
                None
            };

            match self
                .create_issue_with_mapper(project_key, issue, parent, &type_mapper)
                .await
            {
                Ok(created) => {
                    stats.successfully_created += 1;
                    match issue.issue_type.as_str() {
                        "Story" => stats.stories_created += 1,
                        "Task" => stats.tasks_created += 1,
                        _ => {}
                    }
                    created_issues.push(CreatedIssueInfo {
                        key: created.key,
                        id: created.id,
                        issue_type: issue.issue_type.clone(),
                        summary: issue.summary.clone(),
                        status: "To Do".to_string(),
                        self_url: created.self_url,
                    });
                }
                Err(e) => {
                    stats.failed_to_create += 1;
                    failed_issues.push(FailedIssueInfo {
                        issue_type: issue.issue_type.clone(),
                        summary: issue.summary.clone(),
                        error: e.to_string(),
                    });
                }
            }
        }

        Ok(AiTestDataResult {
            scenario,
            created_issues,
            failed_issues,
            stats,
        })
    }

    /// Generate only bugs
    pub async fn generate_bugs(
        &self,
        project_key: &str,
        config: &AiTestDataConfig,
        count: usize,
    ) -> DomainResult<AiTestDataResult> {
        // Fetch available issue types for the project
        log::info!("Fetching issue types for project {}...", project_key);
        let issue_types = self
            .jira_service
            .fetch_issue_types_by_project_key(project_key)
            .await?;

        let type_mapper = IssueTypeMapper::new(&issue_types);
        log::info!(
            "Available issue type mappings: {:?}",
            type_mapper.available_types()
        );

        // Generate bugs
        log::info!("Generating {} bugs with AI...", count);

        let issues = if config.use_claude_cli {
            // Use Claude CLI
            log::info!("Using Claude CLI for generation");
            let client = ClaudeCliClient::new();
            client
                .generate_bugs(&config.project_context, count, config.sprint_duration_days)
                .await?
        } else {
            // Use Claude API
            let claude_config = if config.use_fast_model {
                ClaudeConfig::new(&config.anthropic_api_key).with_haiku()
            } else {
                ClaudeConfig::new(&config.anthropic_api_key)
            };
            let claude_client = ClaudeClient::new(claude_config)?;
            claude_client
                .generate_bugs(&config.project_context, count, config.sprint_duration_days)
                .await?
        };

        let scenario = SprintScenario {
            sprint_name: "Bug Generation".to_string(),
            duration_days: config.sprint_duration_days,
            team_members: vec![],
            issues,
        };

        // Create in JIRA
        let mut created_issues = Vec::new();
        let mut failed_issues = Vec::new();
        let mut stats = GenerationStats::default();
        stats.total_generated = scenario.issues.len();

        for issue in &scenario.issues {
            match self
                .create_issue_with_mapper(project_key, issue, None, &type_mapper)
                .await
            {
                Ok(created) => {
                    stats.successfully_created += 1;
                    stats.bugs_created += 1;

                    let mut info = CreatedIssueInfo {
                        key: created.key.clone(),
                        id: created.id,
                        issue_type: issue.issue_type.clone(),
                        summary: issue.summary.clone(),
                        status: "To Do".to_string(),
                        self_url: created.self_url,
                    };

                    // Apply transitions if configured
                    if config.apply_transitions {
                        if let Some(new_status) =
                            self.apply_timeline_transitions(&created.key, issue).await
                        {
                            info.status = new_status;
                            stats.transitions_applied += 1;
                        }
                    }

                    created_issues.push(info);
                }
                Err(e) => {
                    stats.failed_to_create += 1;
                    failed_issues.push(FailedIssueInfo {
                        issue_type: issue.issue_type.clone(),
                        summary: issue.summary.clone(),
                        error: e.to_string(),
                    });
                }
            }
        }

        Ok(AiTestDataResult {
            scenario,
            created_issues,
            failed_issues,
            stats,
        })
    }

    /// Create a single issue in JIRA with issue type mapping
    async fn create_issue_with_mapper(
        &self,
        project_key: &str,
        issue: &GeneratedIssue,
        parent_key: Option<&str>,
        type_mapper: &IssueTypeMapper,
    ) -> DomainResult<CreatedIssueDto> {
        // Map the AI-generated issue type to the actual project issue type
        let actual_type = type_mapper.map_type(&issue.issue_type).ok_or_else(|| {
            DomainError::Validation(format!(
                "No matching issue type found for '{}'. Available types: {:?}",
                issue.issue_type,
                type_mapper.available_types()
            ))
        })?;

        log::info!(
            "Creating issue type '{}' (mapped from '{}'): {}",
            actual_type,
            issue.issue_type,
            issue.summary
        );

        // Build description with additional context
        let description = if let Some(parent) = parent_key {
            format!("{}\n\n---\nParent Epic: {}", issue.description, parent)
        } else {
            issue.description.clone()
        };

        self.jira_service
            .create_issue(project_key, &issue.summary, Some(&description), actual_type)
            .await
    }

    /// Apply status transitions based on the timeline
    async fn apply_timeline_transitions(
        &self,
        issue_key: &str,
        issue: &GeneratedIssue,
    ) -> Option<String> {
        // Determine target status based on timeline
        let target_status = if issue.completed_day_offset.is_some() {
            "Done"
        } else if issue.started_day_offset.is_some() {
            "In Progress"
        } else {
            return None; // Stay in To Do
        };

        // Try to get transitions and apply
        match self.jira_service.get_issue_transitions(issue_key).await {
            Ok(transitions) => {
                // Find the appropriate transition
                for transition in transitions {
                    let to_status_lower = transition.to_status.to_lowercase();
                    let target_lower = target_status.to_lowercase();

                    if to_status_lower.contains(&target_lower)
                        || target_lower.contains(&to_status_lower)
                    {
                        if self
                            .jira_service
                            .transition_issue(issue_key, &transition.id)
                            .await
                            .is_ok()
                        {
                            // If target is "Done", we may need another transition from "In Progress"
                            if target_status == "Done" && transition.to_status != "Done" {
                                // Try to transition to Done
                                if let Ok(new_transitions) =
                                    self.jira_service.get_issue_transitions(issue_key).await
                                {
                                    for t in new_transitions {
                                        if t.to_status.to_lowercase().contains("done") {
                                            let _ = self
                                                .jira_service
                                                .transition_issue(issue_key, &t.id)
                                                .await;
                                            return Some("Done".to_string());
                                        }
                                    }
                                }
                            }
                            return Some(transition.to_status);
                        }
                    }
                }
                None
            }
            Err(_) => None,
        }
    }
}
